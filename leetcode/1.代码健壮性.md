## 代码健壮性
保证代码的健壮性需要注意以下几点：
- 考虑各种异常情况：在编写代码时，需要考虑各种可能出现的异常情况，例如参数为空、参数非法、内存分配失败等等。需要在代码中加入相应的异常处理机制，以确保代码的稳定性。
- 输入验证：在接收用户输入或者外部数据时，需要进行输入验证，以确保数据的正确性和安全性。例如，对于一个输入数字的函数，需要判断输入是否为数字，以避免输入非数字导致的程序崩溃或安全漏洞。
- 错误处理：在程序中出现错误时，需要及时处理错误，避免错误扩散或者程序崩溃。例如，在内存分配失败时需要及时释放已经分配的内存并给出错误提示。
- 异常处理机制：在代码中加入异常处理机制，以确保程序在出现异常时可以正确处理。例如，在C语言中，可以使用setjmp和longjmp函数实现跳出多层函数调用的异常处理。
- 测试和验证：在编写完代码后，需要进行多种测试和验证，以确保代码的正确性和稳定性。可以使用单元测试、集成测试、功能测试等方法进行测试和验证。
通过以上几点，可以提高代码的健壮性和稳定性，避免程序出现异常和错误。

## 1.将字符串转换成整数
``` c
// ConsoleApplication1_StringToInt.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//1.将字符串转换成整数
//需要处理异常情况
//0.处理空格的情况
//1.有非数字字符串的情况
//2.有正负号的情况
//3.最大正整数和最小的负整数以及溢出的情况

#include <stdio.h>
#include <ctype.h>
#include <limits.h>

int is_space(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v');
}

int is_digit(int c) {
    return c >= '0' && c <= '9';
}

int string_to_int(char* str) {
    if (NULL == str) {
        return 0;
    }
    int sign = 1;  // 用于记录正负号
    int result = 0;
    int i = 0;

    // 跳过开头的空格
    while (is_space(str[i])) {
        i++;
    }

    // 判断正负号
    if (str[i] == '+' || str[i] == '-') {
        sign = (str[i++] == '-') ? -1 : 1;
    }

    // 转换数字部分
    while (is_digit(str[i]) || str[i] == ' ') {
        // 如果遇到空格则继续循环
        if (str[i] == ' ') {
            i++;
            continue;
        }

        // 判断是否溢出
        //如果当前的 result 大于 INT_MAX / 10，那么下一步的乘法运算将会导致整数溢出
        //整型数据类型在表示有符号整数时，通常使用补码来表示
        if (result > INT_MAX / 10 || (result == INT_MAX / 10 && str[i] - '0' > INT_MAX % 10)) {
            return sign == 1 ? INT_MAX : INT_MIN;
        }
        //字符'0'的ASCII码值是48，而字符'9'的ASCII码值是57。
        result = result * 10 + (str[i++] - '0');
    }

    // 返回结果
    return result * sign;
}

int main()
{
    char s1[] = "42";
    char s2[] = "   -4 2";
    char s3[] = "4193 with words";
    char s4[] = "words and 987";
    char s5[] = "-91283472332";

    printf("%d\n", string_to_int(s1)); // output: 42
    printf("%d\n", string_to_int(s2)); // output: -42
    printf("%d\n", string_to_int(s3)); // output: 4193
    printf("%d\n", string_to_int(s4)); // output: 0
    printf("%d\n", string_to_int(s5)); // output: -2147483648 (INT_MIN)
    std::cout << "Hello World!\n";
}

```
## 2.将单链中的倒数第k个链表找出来
``` cpp
/ ConsoleApplication2_The_k-th _endPoint.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//例如，假设链表的长度为n，倒数第k个结点就是正数第n-k+1个结点。如果从头结点开始向前走n-k+1步，就可以到达倒数第k个结点。

//求链表中倒数第k个结点,可以采用双指针法，具体实现可以按照以下步骤：
//判断链表是否为空，如果为空则直接返回 NULL。
//定义两个指针 p 和 q，让它们都指向链表的头结点。
//让指针 p 先向前移动 k - 1 步，如果此时指针 p 已经移动到了链表的末尾，说明链表长度小于 k，返回 NULL。
//接下来让指针 p 和 q 同时向前移动，直到指针 p 移动到链表的最后一个结点。
//最后返回指针 q 所指向的结点。
// 
//求链表中倒数第k个结点时需要考虑以下异常情况：
//链表为空指针。
//k的值小于等于0。
//链表长度小于k。
//k的值大于等于链表长度。

//复杂度为O(N)
#include <iostream>
using namespace std;
//定义链表结构体
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x):val(x),next(nullptr){}
};

//创建链表
ListNode* creat_list(int* arr, int n) {
    if (n == 0 || arr == nullptr) {
        return nullptr;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* p = head;
    for (int i = 1; i < n; i++) {
        ListNode* node = new ListNode(arr[i]);
        p->next = node;
        p = node;
    }
    return head;
}
//打印链表
void print_list(ListNode* head) {
    if (nullptr == head) {
        return;
    }
    ListNode* p = head;
    while (p != nullptr) {
        cout << p->val << " ";
        p = p->next;
    }
    cout << endl;
}
ListNode* find_kth_to_tail(ListNode* head,int k) {
    if (head == nullptr || k <= 0) {
        return nullptr;
    }
    ListNode* p1 = head;
    ListNode* p2 = head;
    //p1先走k-1步
    for (int i = 0; i < k - 1; i++) {
        p1 = p1->next;
        if (p1 == nullptr) {//链表长度小于k
            return nullptr;
        }
    }
    //p1和p2同时走
    while (p1->next != nullptr) {
        p1 = p1->next;
        p2 = p2->next;
    }
    return p2;//返回倒数第k个结点
}
//
int main()
{
    int arr[] = { 1,2,3,4,5 };
    int n = sizeof(arr) / sizeof(int);
    ListNode* head = creat_list(arr, n);
    print_list(head);
    int k = 2;
    ListNode* kthNode = find_kth_to_tail(head, k);
    if (kthNode != nullptr) {
        cout << "The " << k << "th node from tail is " << kthNode->val << endl;
    }else {
        cout << "Invalid input or k is larger than the length of list" << endl;
    }
    return 0;
}

```
## 赋值操作函数
在为一个类添加赋值运算符函数时，需要注意以下几个点：
- 对自身赋值的情况。在赋值运算符函数中，需要检查当前对象是否与参数对象相同。如果相同，则无需进行赋值操作，直接返回当前对象的引用即可。否则，如果在函数中进行了自身赋值，就可能导致程序崩溃或数据丢失。
- 返回引用。赋值运算符函数应该返回指向当前对象的引用。这是因为，如果返回值是对象本身，那么每次调用赋值运算符函数都会创建一个新的对象，这会降低程序的效率。
- 处理动态内存分配。如果类中包含动态分配的内存，赋值运算符函数需要先释放当前对象的内存，再重新分配内存，并将参数对象的数据复制到新分配的内存中。如果不释放旧内存，就会出现内存泄漏问题。
- 安全性和异常安全性。赋值运算符函数需要确保在任何情况下都不会破坏对象的不变量，也就是对象中的数据应该保持一致性。此外，赋值运算符函数应该具有异常安全性，即在出现异常时，应该保证对象的状态不会被修改，从而保证程序的正确性。
- 总之，在为一个类添加赋值运算符函数时，需要仔细考虑类的成员变量的类型和属性，以确保赋值运算符函数能够正确地复制对象的数据，并保持对象的不变量和安全性。
``` cpp
#include <algorithm>
#include <cstring>

class MyClass {
public:
    MyClass(int size = 0) {
        m_size = size;
        m_data = new int[m_size];
    }

    MyClass(const MyClass& other) {
        m_size = other.m_size;
        m_data = new int[m_size];
        std::memcpy(m_data, other.m_data, m_size * sizeof(int));
    }

    ~MyClass() {
        delete[] m_data;
    }

    MyClass& operator=(const MyClass& other) {
        if (this != &other) { // 检查自我赋值
            MyClass tmp(other);
            swap(*this, tmp);
        }
        return *this;
    }

    friend void swap(MyClass& first, MyClass& second) {
        using std::swap;
        swap(first.m_size, second.m_size);
        swap(first.m_data, second.m_data);
    }

private:
    int m_size;
    int* m_data;
};
/*
在这个示例中，我们将赋值运算符函数的参数声明为常量引用，这样可以避免不必要的复制。在函数内部，我们首先检查了自我赋值的情况，如果当前对象和目标对象相同，就直接返回了。否则，我们创建了一个临时对象tmp，其内容和目标对象相同，然后通过swap函数交换当前对象和临时对象的内容。这样做的好处在于，如果new操作失败抛出异常，临时对象将会被销毁，而当前对象内容不会受到影响。在swap函数中，我们仍然使用了标准库中的swap算法，将需要交换的成员进行交换。
*/
```
